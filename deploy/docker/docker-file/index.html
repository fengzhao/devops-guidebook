<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="/devops-guidebook/umi.css" />
    <script>
      window.routerBase = "/devops-guidebook/";
    </script>
    <script>
      //! umi version: 3.2.9
    </script>
    <title>&#x914D;&#x7F6E;&#x811A;&#x672C;</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/deploy/docker/docker-file" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/devops-icon.png&#x27;)" href="/devops-guidebook//">DevOps Guidebook</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span><a href="/devops-guidebook//linux">Linux</a></span><span><a href="/devops-guidebook//server">服务器</a></span><span><a aria-current="page" class="active" href="/devops-guidebook//deploy">部署</a></span><span><a href="/devops-guidebook//code">代码管理</a></span><span><a href="/devops-guidebook//devops">DevOps</a></span><span><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/devops-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></span></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;http://img.mrsingsing.com/devops-icon.png&#x27;)" href="/devops-guidebook//"></a><h1>DevOps Guidebook</h1><p>DevOps 完全知识体系</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/devops-guidebook//linux">Linux</a></li><li><a href="/devops-guidebook//server">服务器</a></li><li><a aria-current="page" class="active" href="/devops-guidebook//deploy">部署</a></li><li><a href="/devops-guidebook//code">代码管理</a></li><li><a href="/devops-guidebook//devops">DevOps</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/devops-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a href="/devops-guidebook//deploy/theory">部署理论</a><ul><li><a href="/devops-guidebook//deploy/theory"><span>基本概述</span></a></li><li><a href="/devops-guidebook//deploy/theory/environment"><span>环境区分</span></a></li><li><a href="/devops-guidebook//deploy/theory/continuous-integration"><span>持续集成</span></a></li><li><a href="/devops-guidebook//deploy/theory/continuous-dilivery"><span>持续交付</span></a></li><li><a href="/devops-guidebook//deploy/theory/continuous-deployment"><span>持续部署</span></a></li><li><a href="/devops-guidebook//deploy/theory/blue-green-deployment"><span>蓝绿部署</span></a></li><li><a href="/devops-guidebook//deploy/theory/gray-release"><span>灰度部署</span></a></li><li><a href="/devops-guidebook//deploy/theory/rolling-update"><span>滚动部署</span></a></li></ul></li><li><a aria-current="page" class="active" href="/devops-guidebook//deploy/docker">Docker</a><ul><li><a href="/devops-guidebook//deploy/docker/overview"><span>基本概述</span></a></li><li><a href="/devops-guidebook//deploy/docker/image"><span>构建镜像</span></a></li><li><a aria-current="page" class="active" href="/devops-guidebook//deploy/docker/docker-file"><span>配置脚本</span></a></li><li><a href="/devops-guidebook//deploy/docker/container"><span>操作容器</span></a></li><li><a href="/devops-guidebook//deploy/docker/storage-patterns-for-persistence"><span>持久存储模式</span></a></li><li><a href="/devops-guidebook//deploy/docker/network"><span>网络通信</span></a></li><li><a href="/devops-guidebook//deploy/docker/operations-and-monitor"><span>运维和监控</span></a></li><li><a href="/devops-guidebook//deploy/docker/docker-compose"><span>多容器部署</span></a></li><li><a href="/devops-guidebook//deploy/docker/command"><span>常用命令</span></a></li><li><a href="/devops-guidebook//deploy/docker/extensions"><span>扩展资源</span></a></li><li><a href="/devops-guidebook//deploy/docker/mongodb"><span>部署 MongoDB</span></a></li></ul></li><li><a href="/devops-guidebook//deploy/github-actions">Github-actions</a><ul><li><a href="/devops-guidebook//deploy/github-actions"><span>Github Actions</span></a></li></ul></li><li><a href="/devops-guidebook//deploy/jenkins">Jenkins</a></li><li><a href="/devops-guidebook//deploy/rancher">Rancher</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="使用方法" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#使用方法"><span>使用方法</span></a></li><li title="环境变量" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#环境变量"><span>环境变量</span></a></li><li title="FROM" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#from"><span>FROM</span></a></li><li title="MAINTAINER" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#maintainer"><span>MAINTAINER</span></a></li><li title="WORKDIR" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#workdir"><span>WORKDIR</span></a></li><li title="ENV" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#env"><span>ENV</span></a></li><li title="ARG" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#arg"><span>ARG</span></a></li><li title="RUN" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#run"><span>RUN</span></a></li><li title="ADD" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#add"><span>ADD</span></a></li><li title="COPY" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#copy"><span>COPY</span></a></li><li title="EXPOSE" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#expose"><span>EXPOSE</span></a></li><li title="ENTRYPOINT" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#entrypoint"><span>ENTRYPOINT</span></a></li><li title="CMD" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#cmd"><span>CMD</span></a></li><li title="传递参数" data-depth="3"><a href="/devops-guidebook//deploy/docker/docker-file#传递参数"><span>传递参数</span></a></li><li title="与 ENTRYPOINT 对比" data-depth="3"><a href="/devops-guidebook//deploy/docker/docker-file#与-entrypoint-对比"><span>与 ENTRYPOINT 对比</span></a></li><li title="EXEC 模式的缺陷" data-depth="3"><a href="/devops-guidebook//deploy/docker/docker-file#exec-模式的缺陷"><span>EXEC 模式的缺陷</span></a></li><li title="VOLUME" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#volume"><span>VOLUME</span></a></li><li title="USER" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#user"><span>USER</span></a></li><li title="LABEL" data-depth="2"><a href="/devops-guidebook//deploy/docker/docker-file#label"><span>LABEL</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="配置脚本"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#配置脚本"><span class="icon,icon-link"></span></a>配置脚本</h1><p>Dockerfile 是由一系列命令和参数构成的脚本，一个 Dockerfile 里面包含了构建整个 Image 的完整命令。Docker 通过 <code>docker build</code> 执行 Dockerfile 中的一系列命令自动构建 Image。</p><p>一般地，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p><table><thead><tr><th align="left">部分</th><th align="left">指令</th></tr></thead><tbody><tr><td align="left">基础镜像信息</td><td align="left">FROM</td></tr><tr><td align="left">维护者信息</td><td align="left">MAINTAINER</td></tr><tr><td align="left">镜像操作指令</td><td align="left">RUN、COPY、ADD、EXPOSE 等</td></tr><tr><td align="left">容器启动时执行指令</td><td align="left">CMD、ENTRYPOINT</td></tr></tbody></table><p><a target="_blank" rel="noopener noreferrer" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Dockerfile 最佳实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h2 id="使用方法"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#使用方法"><span class="icon,icon-link"></span></a>使用方法</h2><p><code>docker build</code> 命令从 Dockerfile 和 <code>context</code> 构建镜像（Image）。<code>context</code> 是 <code>PATH</code> 或 <code>URL</code> 处的文件。<code>PATH</code> 本地文件目录。<code>URL</code> 是 Git Repository 的位置。</p><p><code>context</code> 以递归方式处理。因此，<code>PATH</code> 包括任何子目录，<code>URL</code> 包括 repository 及 submodules。</p><p>一个使用当前目录作为 <code>context</code> 的简单构建命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ docker build </span><span class="token builtin class-name">.</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">Sending build context to Docker daemon </span><span class="token number">6.51</span><span class="token plain">.MB</span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">..</span><span class="token plain">.</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>构建 Docker 守护程序运行，而不是由 CLI 运行。构建过程所做的第一件事是将整个 <code>context</code>（递归地）发送给守护进程。大多数情况下，最好是将 Dockerfile 和所需文件复制到一个空的目录，再到这个目录进行构建。</p><blockquote><p>⚠️ 注意：不要使用根目录 <code>/</code> 作为 <code>PATH</code>，因为它会导致构建将硬盘驱动器的所有内容传输到 Docker 守护程序。</p></blockquote><p><code>build</code> 时添加文件，通过 Dockerfile 引用指令中指定的文件，例如 <code>COPY</code> 指令。要增加构建的性能，请通过将 <code>.dockerignore</code> 文件添加到 <code>context</code> 目录中排除文件和目录。（有关如何创建 <a target="_blank" rel="noopener noreferrer" href="https://deepzz.com/post/dockerfile-reference.html#toc_6">.dockerignore<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 文件的信息）</p><p>一般的，Dockerfile 位于 <code>context</code> 的根中。但使用 <code>-f</code> 标志可指定 Dockerfile 的位置。</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ docker build -f /path/to/Dockerfile</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>如果 build 成功，您可以指定要保存新 Image 的 Repository 和 Tag：</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ docker build -t tsejx/devops </span><span class="token builtin class-name">.</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>要在构建后将 Image 标记为多个 Repositories，请在运行构建命令时添加多个 <code>-t</code> 参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ docker build -t tsejx/myapp:1.0.2 -t tsejx/myapp:latest </span><span class="token builtin class-name">.</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>Docker 守护程序一个接一个地运行 Dockerfile 中的指令，如果需要，将每个指令的结果提交到一个新的 Image，最后输出新映像的 ID。Docker 守护进程将自动清理您发送的 <code>context</code>。</p><p>请注意，每个指令独立运行，并导致创建一个新的 Image，因此 <code>RUN cd / tmp</code> 对下一个指令不会有任何映像。</p><p>只要有可能，Docker 将重新使用中间 Images（缓存），以显著加速 <code>docker build</code> 过程。这由控制台输出中的使用缓存消息指示。</p><p>构建完成后，就可以准备推送至项目仓库。</p><h2 id="环境变量"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#环境变量"><span class="icon,icon-link"></span></a>环境变量</h2><p>环境变量（使用 <code>ENV</code> 语句声明）也可以在某些指令中用作要由 Dockerfile 解释的变量。还可以处理转义，以将类似变量包含在语句中。</p><p>环境变量在 Dockefile 中用 <code>$variable_name</code> 或 <code>$<!-- -->{<!-- -->variable_name<!-- -->}</code> 表示。它们被等同对待，并且括号语法通常用于解决不带空格的变量名的问题，例如 <code>$<!-- -->{<!-- -->foo<!-- -->}<!-- -->_bar</code>。</p><p><code>$<!-- -->{<!-- -->variable_name<!-- -->}</code> 语法还支持以下指定的一些标准 <code>bash</code> 修饰符：</p><ul><li><code>$<!-- -->{<!-- -->variable:-word<!-- -->}</code> 表示如果设置了 <code>variable</code>，则结果将是该值。如果 <code>variable</code> 未设置，那么 <code>word</code> 将是结果。</li><li><code>$<!-- -->{<!-- -->variable:+word<!-- -->}</code> 表示如果设置了 <code>variable</code>，那么 <code>word</code> 将是结果，否则结果是空字符串</li></ul><p>在所有情况下，<code>word</code> 可以是任何字符串，包括额外的环境变量。</p><p>可以通过在变量之前添加 <code>\</code> 来转义：<code>\$foo</code> 或 <code>\$<!-- -->{<!-- -->foo<!-- -->}</code>，分别转换为 <code>$foo</code> 和 <code>$<!-- -->{<!-- -->foo<!-- -->}</code>。</p><p>🌰 <strong>示例</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FROM busybox</span></div><div class="token-line"><span class="token plain">ENV foo /bar</span></div><div class="token-line"><span class="token plain">WORKDIR ${foo}    # WORKDIR /bar</span></div><div class="token-line"><span class="token plain">ADD . $foo        # ADD . /bar</span></div><div class="token-line"><span class="token plain">COPY \$foo /quux  # COPY $foo /quux</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>Dockerfile 中的以下指令列表支持环境变量：</p><ul><li>ADD</li><li>COPY</li><li>ENV</li><li>EXPOSE</li><li>LABEL</li><li>USER</li><li>WORKDIR</li><li>VOLUME</li><li>STOPSIGNAL</li></ul><h2 id="from"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#from"><span class="icon,icon-link"></span></a>FROM</h2><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FROM &lt;image&gt;</span></div><div class="token-line"><span class="token plain"># 或则</span></div><div class="token-line"><span class="token plain">FROM &lt;image&gt;:&lt;tag&gt;</span></div><div class="token-line"><span class="token plain"># 或则</span></div><div class="token-line"><span class="token plain">FROM &lt;image&gt;@&lt;digest&gt;</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>FROM：FROM 是构建镜像的基础源镜像（Base Image）。因此，有效的 Dockerfile 必须具有 FROM 作为其第一条指令。</p><ul><li><code>FROM</code> 必须是 Dockerfile 中的第一个非注释指令。</li><li><code>FROM</code> 可以在单个 Dockerfile 中多次出现，以创建多个图像。只需记下在每个新的 <code>FROM</code> 命令之前由提交输出的最后一个 Image ID</li><li><code>tag</code> 或 <code>digest</code> 是可选的。如果省略其中任何一个，构建器将默认使用 <code>latest</code>。如果构建器与 <code>tag</code> 值不匹配，则构建器将返回错误。</li></ul><p>详细说明：Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令！ 它引入一个镜像作为我们要构建镜像的基础层，就好像我们首先要安装好操作系统，才可以在操作系统上面安装软件一样。</p><h2 id="maintainer"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#maintainer"><span class="icon,icon-link"></span></a>MAINTAINER</h2><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">MAINTAINER &lt;name&gt;</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p><code>MAINTAINER</code> 指令允许您设置生成的 Images 的作者字段</p><h2 id="workdir"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#workdir"><span class="icon,icon-link"></span></a>WORKDIR</h2><p><code>WORKDIR</code> 指令为 Dockerfile 中的任何 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>COPY</code> 和 <code>ADD</code> 指令设置工作目录。</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">WORKDIR /path/to/workdir</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>如果 <code>WORKDIR</code> 不存在，它将会被创建，即使它没有任何后续的 Dockerfile 指令中使用。</p><p>它可以在一个 Dockerfile 中多次使用，如果提供了相对路径，它将相对于先前 <code>WORKDIR</code> 指令的路径。</p><p>🌰 <strong>示例</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">WORKDIR /foo</span></div><div class="token-line"><span class="token plain">WORKDIR bar</span></div><div class="token-line"><span class="token plain">WORKDIR baz</span></div><div class="token-line"><span class="token plain">RUN pwd</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>在这个 Dockerfile 中的最终 <code>pwd</code> 命令的输出是 <code>/foo/bar/baz</code>。</p><p><code>WORKDIR</code> 指令可以解析先前使用 <code>ENV</code> 设置的环境变量。您只能使用 Dockerfile 中显式设置的环境变量。</p><p>🌰 <strong>示例</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ENV DIRPATH /path</span></div><div class="token-line"><span class="token plain">WORKDIR $DIRPATH/$DIRNAME</span></div><div class="token-line"><span class="token plain">RUN pwd</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p><code>pwd</code> 命令在该 Dockerfile 中输出的最后结果是 <code>/path/$DIRNAME</code>。</p><h2 id="env"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#env"><span class="icon,icon-link"></span></a>ENV</h2><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ENV &lt;key&gt; &lt;value&gt;</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENV &lt;key&gt;=&lt;value&gt; ...</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>ENV 指令将环境变量 <code>&lt;key&gt;</code> 设置为值 <code>&lt;value&gt;</code>。</p><p>ENV 指令有两种形式。</p><ul><li>第一种形式，<code>ENV &lt;key&gt; &lt;value&gt;</code>，将单个变量设置为一个值。第一个空格后面的整个字符串将被视为 <code>&lt;value&gt;</code> - 包括空格和引号等字符。</li><li>第二种形式，<code>ENV &lt;key&gt;=&lt;value&gt; ...</code>，允许一次设置多个变量。</li></ul><p>注意，第二种形式在语法中使用等号 <code>=</code>，而第一种形式不使用。与命令行解析类似，引号和反斜杠可用于在值内包含空格。</p><p>更多示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FROM node</span></div><div class="token-line"><span class="token plain">ENV API_URL=google.com \</span></div><div class="token-line"><span class="token plain">    NODE_ENV=production</span></div><div class="token-line"><span class="token plain">    COMMAND=dev</span></div><div class="token-line"><span class="token plain">RUN yarn</span></div><div class="token-line"><span class="token plain">CMD yarn ${COMMAND}</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>启动时运行 <code>docker run --rm -e COMMAND=start -e API_URL=development node</code></p><p>或者要执行的命令复杂的话，可以用 shell script 包在 image 里面，再依照 <code>NODE_ENV</code> 写入需要的环境变量。</p><h2 id="arg"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#arg"><span class="icon,icon-link"></span></a>ARG</h2><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ARG &lt;name&gt;[=&lt;default value&gt;]</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p><code>ARG</code> 指令定义一个变量，用户可以使用 <code>docker build</code> 命令使用 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志，在构建时将其传递给构建器。如果用户指定了一个未在 Dockerfile 中定义的构建参数，构建将输出错误。</p><p>Dockerfile 作者可以通过指定 <code>ARG</code> 一个或多个变量，通过多次指定 <code>ARG</code> 来定义单个变量。例如，一个有效的 Dockerfile：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FROM myapp</span></div><div class="token-line"><span class="token plain">ARG foo</span></div><div class="token-line"><span class="token plain">ARG bar</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>也可以可选地指定 <code>ARG</code> 指令的默认值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FROm myapp</span></div><div class="token-line"><span class="token plain">ARG foo=xyz</span></div><div class="token-line"><span class="token plain">ARG bar=123</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>如果 <code>ARG</code> 值具有缺省值，并且如果在构建时没有传递值，则构建器使用缺省值。</p><p>🌰 <strong>示例</strong></p><p>可以使用 <code>ARG</code> 或 <code>ENV</code> 指令来指定 <code>RUN</code> 指令可用的变量。使用 <code>ENV</code> 指令定义的环境变量总是覆盖同名的 <code>ARG</code> 指令。思考这个 Dockerfile 带有 <code>ENV</code> 和 <code>ARG</code> 指令。</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FROM ubuntu</span></div><div class="token-line"><span class="token plain">ARG CONT_IMG_VER</span></div><div class="token-line"><span class="token plain">ENV CONT_IMG_VER v1.0.0</span></div><div class="token-line"><span class="token plain">RUN echo $CONT_IMG_VER</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>构建命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ docker build --build-arg </span><span class="token assign-left variable">CONT_IMG_VER</span><span class="token operator">=</span><span class="token plain">v2.0.1 Dockerfile</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>在这种情况下，<code>RUN</code> 指令使用 v1.0.0 而不是用户传递的 <code>ARG</code> 设置：<code>v2.0.1</code> 此行为类似于 shell 脚本，其中本地作用域变量覆盖作为参数传递或从环境继承的变量，从其定义点。</p><p>🌰 <strong>示例</strong></p><p>使用上述示例，但使用不同的 <code>ENV</code> 规范，您可以在 <code>ARG</code> 和 <code>ENV</code> 指令之间创建更有用的交互：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FROM ubuntu</span></div><div class="token-line"><span class="token plain">ARG CONT_IMG_VER</span></div><div class="token-line"><span class="token plain">ENV CONT_IMG_VER ${CONT_IMG_VER:-v1.0.0}</span></div><div class="token-line"><span class="token plain">RUN echo $CONT_IMG_VER</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>与 <code>ARG</code> 指令不同，<code>ENV</code> 值始终保留在 Image 中。考虑一个没有 <code>-build-arg</code> 标志的 docker 构建：</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ docker build Dockerfile</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>使用这个 Dockerfile 示例，<code>CONT_IMG_VER</code> 仍然保留在映像中，但它的值将是 <code>v1.0.0</code>，因为它是 <code>ENV</code> 指令在第 3 行中的默认设置。</p><p><a target="_blank" rel="noopener noreferrer" href="https://docs.docker.com/engine/reference/builder/#environment-replacement">环境变量替代<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p><code>ARG</code> 变量不会持久化到构建的 Image 中，而 <code>ENV</code> 变量则会。但是，<code>ARG</code> 变量会以类似的方式影响构建缓存。如果一个 Dockerfile 定义一个 <code>ARG</code> 变量，它的值不同于以前的版本，那么在它的第一次使用时会出现一个 <code>“cache miss”</code>，而不是它的定义。特别地，在 <code>ARG</code> 指令之后的所有 RUN 指令都隐式地使用 <code>ARG</code> 变量（作为环境变量），因此可能导致高速缓存未命中。</p><h2 id="run"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#run"><span class="icon,icon-link"></span></a>RUN</h2><p>RUN：后面跟的是在容器中要执行的命令。有两种形式：</p><ul><li><code>RUN &lt;command&gt;</code> shell 形式，命令在 Shell 中运行，Linux 上为 <code>/bin/sh/ -c</code>，Windows 上为 <code>cmd /S/C</code></li><li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> exec 形式</li></ul><p>⚠️ <strong>注意</strong>：每一个 <code>RUN</code> 指令都会新建立一层，在其上执行这些命令，当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错因此，在很多情况下，我们可以合并指令并运行，例如 <code>RUN apt-get update &amp;&amp; apt-get install -y libgdiplus</code>。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易。除此之外，<code>Union FS</code> 是有最大层数限制的，不能超过 <code>127</code> 层，而且我们应该把每一层中我用文件清除，比如一些没用的依赖，来防止镜像臃肿。</p><h2 id="add"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#add"><span class="icon,icon-link"></span></a>ADD</h2><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ADD &lt;src&gt; &lt;dest&gt;</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"># 对于包含空格的路径，此形式是必需的</span></div><div class="token-line"><span class="token plain">ADD [&quot;&lt;src&gt;&quot;, ..., &quot;&lt;dest&gt;&quot;]</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>ADD 指令与 COPY 指令非常类似，但它包含更多功能。除了将文件从主机复制到容器映像，ADD 指令还可以使用 URL 规范从远程位置复制文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ADD https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe /temp/python-3.5.1.exe</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p><code>ADD</code> 遵守以下规则：</p><ul><li><code>&lt;src&gt;</code> 路径必须在构建的上下文中;你不能 <code>ADD ../something /something</code>，因为 Docker 构建的第一步是发送上下文目录（和子目录）到 Docker 守护进程。如果 <code>&lt;src&gt;</code> 是 <code>URL</code> 并且 <code>&lt;dest&gt;</code> 不以尾部斜杠结尾，则从 <code>URL</code> 下载文件并将其复制到 <code>&lt;dest&gt;</code>。如果 <code>&lt;src&gt;</code> 是 <code>URL</code> 并且 <code>&lt;dest&gt;</code> 以尾部斜杠结尾，则从 <code>URL</code> 中推断文件名，并将文件下载到 <code>&lt;dest&gt;/&lt;filename&gt;</code>。例如，<code>ADD http://example.com/foobar /</code> 会创建文件 <code>/ foobar</code>。网址必须有一个非平凡的路径，以便在这种情况下可以发现一个适当的文件名（<code>http://example.com</code> 不会工作）。如果 <code>&lt;src&gt;</code> 是目录，则复制目录的整个内容，包括文件系统元数据。</li></ul><h2 id="copy"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#copy"><span class="icon,icon-link"></span></a>COPY</h2><p>拷贝文件至容器的工作目录下，<code>.dockerignore</code> 指定的文件不会拷贝。</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">COPY &lt;src&gt; .. &lt;dest&gt;</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">COPY [&quot;&lt;src&gt;&quot;, ..., &quot;&lt;dest&gt;&quot;]</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>与 ADD 类似，不过 <code>COPY</code> 的 <code>&lt;src&gt;</code> 不能为 URL。</p><p>如果源或目标包含空格，请将路径括在方括号和双引号中。</p><h2 id="expose"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#expose"><span class="icon,icon-link"></span></a>EXPOSE</h2><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p><code>EXPOSE</code> 指令通知 Docker 容器在运行时侦听指定的网络端口。<code>EXPOSE</code> 不使主机的容器的端口可访问。为此，必须使用 <code>-p</code> 标志发布一系列端口，或者使用 <code>-P</code> 标志发布所有暴露的端口。您可以公开一个端口号，并用另一个端口号在外部发布。</p><p>要在主机系统上设置端口重定向，请参阅 <a target="_blank" rel="noopener noreferrer" href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports">使用 <code>-P</code> 标志<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。Docker 网络功能支持创建网络，无需在网络中公开端口，有关详细信息，请参阅 <a target="_blank" rel="noopener noreferrer" href="https://docs.docker.com/engine/userguide/networking/">网络通信功能的概述<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h2 id="entrypoint"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#entrypoint"><span class="icon,icon-link"></span></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code> 允许您配置容器，运行执行的可执行文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 使用 exec 执行</span></div><div class="token-line"><span class="token plain">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"># 使用 shell 执行</span></div><div class="token-line"><span class="token plain">ENTRYPOINT command param1 param2</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。</p><p>例如，以下将使用其默认内容启动 Nginx，侦听端口 80：</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ docker run -it --rm -p </span><span class="token number">80</span><span class="token plain">:80 nginx</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h2 id="cmd"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#cmd"><span class="icon,icon-link"></span></a>CMD</h2><p><code>CMD</code> 指令有三种形式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 使用 exec 执行，推荐方式</span></div><div class="token-line"><span class="token plain"># 这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号</span></div><div class="token-line"><span class="token plain">CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"># 在 /bin/sh 中执行，提供给需要交互的应用</span></div><div class="token-line"><span class="token plain"># 实际命令会被包装为 sh -c 的参数形式进行执行</span></div><div class="token-line"><span class="token plain">CMD command param1 param2</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"># 提供给 ENTRYPOINT 的默认参数</span></div><div class="token-line"><span class="token plain">CMD [&quot;param1&quot;, &quot;param2&quot;]</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># shell</span></div><div class="token-line"><span class="token plain">CMD echo $HOME</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"># 转化为 exec 即</span></div><div class="token-line"><span class="token plain">CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot;]</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>指定启动容器时执行命令，每个 Dockerfile 只能有一个 <code>CMD</code> 指令。如果指定了多条命令，则只有最后一条会被执行。</p><p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。</p><p>CMD 后面的命令是容器每次启动执行的命令，多个命令之间可以使用 <code>&amp;&amp;</code> 链接，例如 <code>CMD git pull &amp;&amp; npm start</code>。</p><p>容器中的应用都应该以前台执行，而不是启动后台服务，容器内没有后台服务的概念。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义。 比如 <code>CMD service nginx start</code> 它等同于 <code>CMD [ &quot;bash&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code> 主进程实际上是 <code>bash</code>，<code>bash</code> 也就结束了，<code>bash</code> 作为主进程退出了。</p><h3 id="传递参数"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#传递参数"><span class="icon,icon-link"></span></a>传递参数</h3><h4 id="固定参数"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#固定参数"><span class="icon,icon-link"></span></a>固定参数</h4><p>Dockerfile 如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">FROM python:2.7-slim</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">COPY startup.sh /opt</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">RUN chmod +x /opt/startup.sh</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ARG envType=xxx</span></div><div class="token-line"><span class="token plain">ENV envType ${envType}</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">CMD [&quot;/opt/startup.sh&quot;, &quot;foo&quot;]</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>构建并启动：</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token comment"># docker build</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">docker build -t yellow:1.0 --build-arg </span><span class="token assign-left variable">envType</span><span class="token operator">=</span><span class="token plain">dev </span><span class="token builtin class-name">.</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment"># docker run</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">docker run -it --rm</span><span class="token operator">=</span><span class="token plain">true yellow:1.0</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h4 id="动态参数"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#动态参数"><span class="icon,icon-link"></span></a>动态参数</h4><p><a target="_blank" rel="noopener noreferrer" href="https://docs.docker.com/engine/reference/builder/#cmd">Docker Documentation：CMD<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><ul><li><code>exec</code> 形式的 <code>CMD</code>，是 docker 来运行命令，是不支持参数替换的</li><li><code>shell</code> 形式的 <code>CMD</code>，是 docker 来运行 <code>sh</code>，<code>sh</code> 再运行我们写的命令，而 <code>sh</code> 是支持参数替换的</li></ul><p>Dockerfile 最后一行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">CMD /opt/startup.sh ${envType}</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>构建并启动：</p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token comment"># docker build</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">docker build -t yellow:4.0 --build-arg </span><span class="token assign-left variable">envType</span><span class="token operator">=</span><span class="token plain">dev </span><span class="token builtin class-name">.</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token comment"># docker run</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">docker run -ti --rm</span><span class="token operator">=</span><span class="token plain">true yellow:4.0</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h3 id="与-entrypoint-对比"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#与-entrypoint-对比"><span class="icon,icon-link"></span></a>与 ENTRYPOINT 对比</h3><p>共同点：</p><ol><li>都可以指定 Shell 或 exec 函数调用的方式执行命令</li><li>当存在多个 <code>CMD</code> 指令或 <code>ENTRYPOINT</code> 指令时，只有最后一个生效</li></ol><p>差异：</p><ol><li><p><code>CMD</code> 指令指定的容器启动时命令可以被 <code>docker run</code> 指定的命令覆盖，而 <code>ENTRYPOINT</code> 指令指定的命令不能被覆盖，而是将 <code>docker run</code> 指定的参数当做 <code>ENTRYPOINT</code> 指定命令的参数</p></li><li><p><code>CMD</code> 指令可以为 <code>ENTRYPOINT</code> 指令设置默认参数，而且可以被 <code>docker run</code> 指定的参数覆盖</p></li></ol><p>总结：</p><ul><li>如果 ENTRYPOINT 使用了 shell 模式，CMD 指令会被忽略</li><li>如果 ENTRYPOINT 使用了 exec 模式，CMD 指定的内容被追加为 ENTRYPOINT 指定命令的参数</li><li>如果 ENTRYPOINT 使用了 exec 模式，CMD 也应该使用 exec 模式</li></ul><p><code>exec</code> 模式是建议的使用模式，因为当运行任务的进程作为容器中的 1 号进程时，我们可以通过 docker 的 stop 命令优雅地结束容器。</p><h3 id="exec-模式的缺陷"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#exec-模式的缺陷"><span class="icon,icon-link"></span></a>EXEC 模式的缺陷</h3><p>⚠️ <strong>注意：</strong> <code>exec</code> 模式不能使用环境变量。因为 <code>exec</code> 模式的特点是不会通过 shell 执行相关的命令。</p><p>🌰 <strong>示例：Shell 模式</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ </span><span class="token function">cat</span><span class="token plain"> Dockerfile</span></div><div class="token-line"><span class="token plain">FROM oraclelinux</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ADD ./docker-entry.sh   /docker-entry.sh</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENV VAR Hello</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT  </span><span class="token string">&quot;/docker-entry.sh&quot;</span><span class="token plain"> </span><span class="token string">&quot;</span><span class="token string variable">${VAR}</span><span class="token string">&quot;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">$ docker run --rm testimage</span></div><div class="token-line"><span class="token plain">Entry of ENTRYPOINT, ARGS</span><span class="token punctuation">[</span><span class="token comment">#]=1</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT ARGS</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token plain">/docker-entry.sh</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT ARGS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token plain">Hello</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token variable">$@</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token plain">Hello</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>🌰 <strong>示例：EXEC 模式</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ </span><span class="token function">cat</span><span class="token plain"> Dockerfile</span></div><div class="token-line"><span class="token plain">FROM oraclelinux</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ADD ./docker-entry.sh   /docker-entry.sh</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENV VAR Hello</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT  </span><span class="token punctuation">[</span><span class="token plain"> </span><span class="token string">&quot;/docker-entry.sh&quot;</span><span class="token plain">, </span><span class="token string">&quot;</span><span class="token string variable">${VAR}</span><span class="token string">&quot;</span><span class="token plain"> </span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">$ docker run --rm testimage</span></div><div class="token-line"><span class="token plain">Entry of ENTRYPOINT, ARGS</span><span class="token punctuation">[</span><span class="token comment">#]=1</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT ARGS</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token plain">/docker-entry.sh</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT ARGS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token variable">${VAR}</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token variable">$@</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token variable">${VAR}</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>这个环境变量 <code>$VAR</code> 没有被替换掉，而是源文本的方式穿下去了。</p><p>解决这个问题的办法使用 <code>&quot;bash -c&quot;</code> 来调用 ENTRYPOINT 指令：</p><p>🌰 <strong>示例：EXEC 模式</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-bash"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ </span><span class="token function">cat</span><span class="token plain"> Dockerfile</span></div><div class="token-line"><span class="token plain">FROM oraclelinux</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ADD ./docker-entry.sh   /docker-entry.sh</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENV VAR Hello</span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT  </span><span class="token punctuation">[</span><span class="token plain"> </span><span class="token string">&quot;/bin/bash&quot;</span><span class="token plain">, </span><span class="token string">&quot;-c&quot;</span><span class="token plain">, </span><span class="token string">&quot;/docker-entry.sh </span><span class="token string variable">${VAR}</span><span class="token string">&quot;</span><span class="token plain"> </span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">$ docker run --rm testimage</span></div><div class="token-line"><span class="token plain">Entry of ENTRYPOINT, ARGS</span><span class="token punctuation">[</span><span class="token comment">#]=1</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT ARGS</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token plain">/docker-entry.sh</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">ENTRYPOINT ARGS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token plain">Hello</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token variable">$@</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token plain">Hello</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h2 id="volume"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#volume"><span class="icon,icon-link"></span></a>VOLUME</h2><p><code>VOLUME</code> 指令创建具有指定名称的挂载点，并将其标记为从本机主机或其他容器保留外部挂载的卷。该值可以是 JSON 数组 <code>VOLUME [&quot;/var/log&quot;]</code> 或具有多个参数的纯字符串，例如 <code>VOLUME /var/log</code> 或 <code>VOLUME /var/log /var/db</code>。</p><h2 id="user"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#user"><span class="icon,icon-link"></span></a>USER</h2><p><code>USER</code> 指令设置运行 Image 时使用的用户名或 UID，以及 Dockerfile 中的任何 <code>RUN</code>、<code>CMD</code> 和 <code>ENTRYPOINT</code> 指令。</p><h2 id="label"><a aria-hidden="true" tabindex="-1" href="/devops-guidebook//deploy/docker/docker-file#label"><span class="icon,icon-link"></span></a>LABEL</h2><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p><code>LABEL</code> 指令向 Image 添加元数据。<code>LABEL</code> 是键值对。要在 <code>LABEL</code> 值中包含空格，请使用引号和反斜杠，就像在命令行解析中一样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">LABEL &quot;com.example.vendor&quot;=&quot;ACME Incorporated&quot;</span></div><div class="token-line"><span class="token plain">LABEL com.example.label-with-value=&quot;foo&quot;</span></div><div class="token-line"><span class="token plain">LABEL version=&quot;1.0&quot;</span></div><div class="token-line"><span class="token plain">LABEL description=&quot;This text illustrates \</span></div><div class="token-line"><span class="token plain">that label-values can span multiple lines.&quot;</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>Image 可以有多个 Label。要指定多个 Label，Docker 建议在可能的情况下将标签合并到单个 <code>LABEL</code> 指令中。每个 <code>LABEL</code> 指令产生一个新层，如果使用许多标签，可能会导致效率低下的图像。该示例产生单个图像层。</p><div class="__dumi-default-code-block"><pre class="prism-code language-dockerfile"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">LABEL multi.label1=&quot;value1&quot; multi.label2=&quot;value2&quot; other=&quot;value3&quot;</span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>标签是添加的，包括 <code>LABEL</code> 在 <code>FROM images</code> 中。如果 Docker 遇到已经存在的 <code>label/key</code>，则新值将覆盖具有相同键的任何先前标签。</p><p>要查看 Image 的 labels，请使用 <code>docker inspect</code> 命令。</p><hr/><p><strong>参考资料：</strong></p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5d9c0224f265da5b76373451">📝 Dockerfile 和 Docker Compose file 参考文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5922e07cda2f60005d602dcd">📝 如何编写最佳的 Dockerfile<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#build-cache">📝 Dockerfile 最佳实践指南：构建缓存部分<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://www.cnblogs.com/sparkdev/p/8461576.html">📝 Dockerfile 中的 CMD 与 ENTRYPOINT<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/tsejx/devops-guidebook/edit/master/docs/deploy/docker/docker-file.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last update: ">6/20/2022 09:42:41</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/devops-guidebook/umi.js"></script>
    <script src="/devops-guidebook/docs__deploy__docker__docker-file.md.js"></script>
  </body>
</html>
